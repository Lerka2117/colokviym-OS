# Коллоквиум ОС
# Евтухович Лера Валерьевна 9 группа Вариант 2
1.  Приведите Win API, необходимое для решения Лабораторной работы номер 2;
Для работы с процессами и потоками в Windows могут потребоваться следующие WinAPI-функции:  
- CreateProcess() – создание процесса;  
- CreateThread() – создание потока;  
- WaitForSingleObject() / WaitForMultipleObjects() – ожидание завершения потока/процесса;  
- ExitProcess() – завершение процесса;  
- TerminateProcess() – принудительное завершение процесса;  
- GetCurrentProcess() / GetCurrentThread() – получение дескрипторов текущего процесса/потока;  
- CloseHandle() – закрытие дескриптора.  

Для синхронизации:  
- CreateMutex(), ReleaseMutex() – мьютекс;  
- CreateSemaphore(), ReleaseSemaphore() – семафор;  
- InitializeCriticalSection(), EnterCriticalSection(), LeaveCriticalSection() – критическая секция;  
- CreateEvent(), SetEvent(), ResetEvent() – события.  
2.  Что такое процесс в ОС Windows;
  Процесс – экземпляр выполняемой программы, включающий:  
- Виртуальное адресное пространство;  
- Код, данные, стек, кучу;  
- Дескрипторы ресурсов (файлы, сокеты, мьютексы и т. д.);  
- Минимум один поток выполнения.  
3.  Что такое Критическая секция;
  Критическая секция – механизм синхронизации потоков в рамках одного процесса, обеспечивающий эксклюзивный доступ к общему ресурсу.  
- Используется для защиты данных от одновременного изменения разными потоками. 
4.  Что такое Семафор;
  Семафор – объект синхронизации, ограничивающий количество потоков, одновременно работающих с ресурсом.  
- Имеет счётчик (например, максимальное число потоков в БД).  
5.  Сравнительный анализ стандарта C++ 98 с и без применения библиотеки boost или свежего стандарта с \ без использованием библиоnеки QT (в контексте лабораторных)
  | Критерий       | C++98                          | C++11/14/17 (+Boost/Qt)          |   
| Умные указатели     | Нет (`auto_ptr` – небезопасный)    | shared_ptr, unique_ptr (Boost/STL)|  
| Многопоточность     | Нет в стандарте (WinAPI/POSIX)     | <thread>, <mutex>, <atomic>    |  
| Лямбды             | Нет                                | Есть (`[=](){ ... }`)                |  
| Контейнеры         | Базовые (`vector`, list`)         | `unordered_map, forward_list      |  
| Синхронизация      | Критические секции (WinAPI)        | std::mutex, std::condition_variable |  

Boost/Qt:  
- Boost: Добавляет asio (сеть), filesystem (работа с файлами), signals2 (события).  
- Qt: QThread, QMutex, signals/slots (альтернатива callback).
# Общие вопросы:
1. Что такое ООП? – полное определение;
   Объектно-ориентированное программирование (ООП) — это подход, при котором программа рассматривается как набор объектов, взаимодействующих друг с другом.
   Определение: Методология программирования, основанная на:  
Абстракции – моделирование сущностей через классы.  
Инкапсуляции – сокрытие деталей реализации (`private`/`public`).  
Наследовании – создание иерархии классов (`class Derived : public Base`).  
Полиморфизме – переопределение методов (`virtual`, интерфейсы).  
2. Магическое число 7 Миллера? – привести не менее 7 примеров из IT;
   Теория: Человек может одновременно удерживать 7±2 единицы информации.  
Примеры в IT:  
1. Макс. 7±2 параметров у функции (иначе сложно читать).  
2. 7±2 вкладок в IDE (переключение становится неудобным).  
3. 7±2 пунктов в меню навигации сайта.  
4. 7±2 уровня вложенности if (условия становятся запутанными).  
5. 7±2 модуля в микросервисной архитектуре (управляемость).  
6. 7±2 столбцов в таблице БД (оптимально для восприятия).  
7. 7±2 шагов в wizard-интерфейсе (UX-дизайн).  
3. Энтропия ПО? – привести не менее 5 примеров нег энтропийных мер при разработке ПО;
   Энтропия ПО – мера хаоса в коде (рост сложности и беспорядка со временем).  
Анти-энтропийные меры:  
1. Рефакторинг – упрощение кода без изменения функционала.  
2. Инкапсуляция – сокрытие деталей реализации.  
3. Юнит-тесты – предотвращение "поломок" при изменениях.  
4. CI/CD – автоматизация сборки и деплоя.  
5. Документация – снижение неопределённости в архитектуре.  
4. 5 признаков сложной системы по Гради Бучу – по каждому признаку привести не менее 2-х пояснительных примером из Ваших Лабораторных работ или pet проектов;
   1. Иерархичность  
   - Пример 1: Многоуровневая архитектура (GUI → Logic → DB).  
   - Пример 2: Наследование классов в ООП.  
2. Эмерджентность (свойства системы ≠ сумме свойств частей)  
   - Пример 1: Deadlock из-за взаимодействия потоков.  
   - Пример 2: Неочевидные баги при интеграции модулей.  
3. Децентрализованное управление  
   - Пример 1: Микросервисы (каждый сервис автономен).  
   - Пример 2: Peer-to-peer сети (нет единого сервера).  
4. Неопределённость поведения  
   - Пример 1: Race condition в многопоточности.  
   - Пример 2: Непредсказуемость AI в играх.  
5. Адаптивность  
   - Пример 1: Plug-in архитектура (добавление новых модулей).  
   - Пример 2: Динамическая загрузка DLL.  
5. Закон иерархических компенсаций Седова – привести не менее 5 исторических примеров применения закона Седова в эволюции IT сферы;
   Суть: Рост сложности системы требует перераспределения управления между уровнями иерархии.
   Примеры в IT:  
1. Переход от монолита к микросервисам (компенсация сложности масштабированием).  
2. Виртуализация (абстрагирование железа через гипервизор).  
3. Кэширование (компенсация медленного доступа к данным).  
4. Шардирование БД (распределение нагрузки).  
5. Слоистая архитектура ОС (ядро → драйверы → пользовательские процессы).  
